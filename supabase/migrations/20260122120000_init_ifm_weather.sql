-- IFM Weather: initial schema for Supabase (Postgres)

-- Locations
create table if not exists public.locations (
  id bigint generated by default as identity primary key,
  name text not null,
  region text null,
  latitude numeric(9,6) not null,
  longitude numeric(9,6) not null,
  timezone text not null default 'Africa/Dar_es_Salaam',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint locations_lat_lon_unique unique (latitude, longitude)
);

-- Forecasts
create table if not exists public.forecasts (
  id bigint generated by default as identity primary key,
  location_id bigint not null references public.locations(id) on delete cascade,
  observed_at timestamptz not null,
  temp_c numeric(5,2) null,
  feels_like_c numeric(5,2) null,
  humidity smallint null,
  wind_ms numeric(5,2) null,
  rain_mm numeric(6,2) not null default 0,
  summary text null,
  raw jsonb null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
create index if not exists forecasts_location_observed_idx on public.forecasts (location_id, observed_at desc);

-- Alerts
create table if not exists public.alerts (
  id bigint generated by default as identity primary key,
  location_id bigint not null references public.locations(id) on delete cascade,
  level text not null,
  type text not null,
  title text not null,
  message text null,
  starts_at timestamptz not null,
  ends_at timestamptz null,
  source text not null default 'system',
  rule_ref text null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
create index if not exists alerts_location_starts_idx on public.alerts (location_id, starts_at desc);
create index if not exists alerts_active_idx on public.alerts (location_id, ends_at);

-- Reports (aka hazards)
create table if not exists public.reports (
  id bigint generated by default as identity primary key,
  location_id bigint not null references public.locations(id) on delete cascade,
  type text not null,
  severity text null,
  note text null,
  photo_url text null,
  reported_at timestamptz not null default now(),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
create index if not exists reports_location_reported_idx on public.reports (location_id, reported_at desc);

-- Device tokens (Expo push)
create table if not exists public.device_tokens (
  id bigint generated by default as identity primary key,
  expo_token text not null,
  platform text null,
  location_id bigint null references public.locations(id) on delete set null,
  last_seen_at timestamptz null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint device_tokens_expo_unique unique (expo_token)
);

-- Simple updated_at trigger
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

do $$
begin
  if not exists (select 1 from pg_trigger where tgname = 'set_locations_updated_at') then
    create trigger set_locations_updated_at before update on public.locations
    for each row execute function public.set_updated_at();
  end if;
  if not exists (select 1 from pg_trigger where tgname = 'set_forecasts_updated_at') then
    create trigger set_forecasts_updated_at before update on public.forecasts
    for each row execute function public.set_updated_at();
  end if;
  if not exists (select 1 from pg_trigger where tgname = 'set_alerts_updated_at') then
    create trigger set_alerts_updated_at before update on public.alerts
    for each row execute function public.set_updated_at();
  end if;
  if not exists (select 1 from pg_trigger where tgname = 'set_reports_updated_at') then
    create trigger set_reports_updated_at before update on public.reports
    for each row execute function public.set_updated_at();
  end if;
  if not exists (select 1 from pg_trigger where tgname = 'set_device_tokens_updated_at') then
    create trigger set_device_tokens_updated_at before update on public.device_tokens
    for each row execute function public.set_updated_at();
  end if;
end $$;

-- RLS: since we'll go through Edge Functions (service role), lock tables by default.
alter table public.locations enable row level security;
alter table public.forecasts enable row level security;
alter table public.alerts enable row level security;
alter table public.reports enable row level security;
alter table public.device_tokens enable row level security;

-- Optional: allow public read for app without auth.
-- If you ONLY want Edge Functions to access data, leave these commented.
-- create policy "public read locations" on public.locations for select using (true);
-- create policy "public read forecasts" on public.forecasts for select using (true);
-- create policy "public read alerts" on public.alerts for select using (true);
-- create policy "public read reports" on public.reports for select using (true);

-- Inserts from public clients are best done via Edge Functions; keep them blocked by RLS.
